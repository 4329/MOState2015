// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "ForwardDrive.h"

#include "Commands/MoveForwardDrive.h"

#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

ForwardDrive::ForwardDrive() : Subsystem("ForwardDrive") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	forwardLeftTalon = RobotMap::forwardDriveForwardLeftTalon;
	forwardRightTalon = RobotMap::forwardDriveForwardRightTalon;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	Config();
}
    
void ForwardDrive::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new MoveForwardDrive());
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void ForwardDrive::Config()
{
	LeftPulsesPerInch = 0;
	RightPulsesPerInch = 0;

	HighSpeedRate = Preferences::GetInstance()->GetFloat("ForwardDrive::HighSpeed");
	LowSpeedRate = Preferences::GetInstance()->GetFloat("ForwardDrive::LowSpeed");
	PulsesPerDeg = Preferences::GetInstance()->GetInt("ForwardDrive::QuadEncoder::PulsesPerDegree");

	if (Preferences::GetInstance()->GetBoolean("ForwardDrive::LeftTalon::EnablePID"))
	{
		LeftPulsesPerInch = Preferences::GetInstance()->GetInt("ForwardDrive::LeftTalon::QuadEncoder::PulsesPerInch");
		forwardLeftTalon->SetFeedbackDevice(CANTalon::QuadEncoder);
		if (Preferences::GetInstance()->GetBoolean("ForwardDrive::LeftTalon::SensorReversed"))
		{
			forwardLeftTalon->SetSensorDirection(true);
		} else
		{
			forwardLeftTalon->SetSensorDirection(false);
		}
		forwardLeftTalon->SetP(Preferences::GetInstance()->GetDouble("ForwardDrive::LeftTalon::PID::P"));
		forwardLeftTalon->SetI(Preferences::GetInstance()->GetDouble("ForwardDrive::LeftTalon::PID::I"));
		forwardLeftTalon->SetD(Preferences::GetInstance()->GetDouble("ForwardDrive::LeftTalon::PID::D"));
		forwardLeftTalon->SetF(Preferences::GetInstance()->GetDouble("ForwardDrive::LeftTalon::PID::F"));
		if(Preferences::GetInstance()->GetBoolean("ForwardDrive::LeftTalon::EnableVoltRampRate"))
		{
			forwardLeftTalon->SetVoltageRampRate(Preferences::GetInstance()->GetDouble("ForwardDrive::LeftTalon::VoltRampRate"));
		}

		if (Preferences::GetInstance()->GetBoolean("ForwardDrive::LeftTalon::EnableCLRampRate"))
		{
			forwardLeftTalon->SetCloseLoopRampRate(Preferences::GetInstance()->GetDouble("ForwardDrive::LeftTalon::CLRampRate"));
		}

		forwardLeftTalon->SetIzone(Preferences::GetInstance()->GetInt("ForwardDrive::LeftTalon::IZone"));

	}

	if (Preferences::GetInstance()->GetBoolean("ForwardDrive::RightTalon::EnablePID"))
	{
		RightPulsesPerInch = Preferences::GetInstance()->GetInt("ForwardDrive::RightTalon::QuadEncoder::PulsesPerInch");
		forwardRightTalon->SetFeedbackDevice(CANTalon::QuadEncoder);
		if (Preferences::GetInstance()->GetBoolean("ForwardDrive::RightTalon::SensorReversed"))
		{
			forwardRightTalon->SetSensorDirection(true);
		} else
		{
			forwardRightTalon->SetSensorDirection(false);
		}
		forwardRightTalon->SetP(Preferences::GetInstance()->GetDouble("ForwardDrive::RightTalon::PID::P"));
		forwardRightTalon->SetI(Preferences::GetInstance()->GetDouble("ForwardDrive::RightTalon::PID::I"));
		forwardRightTalon->SetD(Preferences::GetInstance()->GetDouble("ForwardDrive::RightTalon::PID::D"));
		forwardRightTalon->SetF(Preferences::GetInstance()->GetDouble("ForwardDrive::RightTalon::PID::F"));
		if(Preferences::GetInstance()->GetBoolean("ForwardDrive::RightTalon::EnableVoltRampRate"))
		{
			forwardRightTalon->SetVoltageRampRate(Preferences::GetInstance()->GetDouble("ForwardDrive::RightTalon::VoltRampRate"));
		}

		if (Preferences::GetInstance()->GetBoolean("ForwardDrive::RightTalon::EnableCLRampRate"))
		{
			forwardRightTalon->SetCloseLoopRampRate(Preferences::GetInstance()->GetDouble("ForwardDrive::RightTalon::CLRampRate"));
		}

		forwardRightTalon->SetIzone(Preferences::GetInstance()->GetInt("ForwardDrive::RightTalon::IZone"));

	}
}


void ForwardDrive::SetDrive_Arcade(float x, float y, bool highRate)
{
	float tx, ty;

	tx = Limit(x);
	ty = Limit(y);

	printf("FD X %f   Y %f\n",tx,ty);
	if (ty > 0.0)
	{

		if (tx > 0.0)
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = std::max(ty, tx);
		}
		else if (tx < 0.0)
		{
			leftMotorOutput = std::max(ty, -tx);
			rightMotorOutput = ty + tx;
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	else
	{
		if (tx > 0.0)
		{
			leftMotorOutput = - std::max(-ty, tx);
			rightMotorOutput = ty + tx;
		}
		else if (tx < 0.0)
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = - std::max(-ty, -tx);
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}

	if (highRate)
	{
		forwardLeftTalon->Set(leftMotorOutput*HighSpeedRate);
		forwardRightTalon->Set(rightMotorOutput*HighSpeedRate);
	} else
	{
		forwardLeftTalon->Set(leftMotorOutput*LowSpeedRate);
		forwardRightTalon->Set(rightMotorOutput*LowSpeedRate);
	}
}

void ForwardDrive::SetDrive_Tank(float left, float right, bool highRate)
{
	if (highRate)
	{
		forwardLeftTalon->Set(Limit(left)*HighSpeedRate);
		forwardRightTalon->Set(Limit(right)*HighSpeedRate);
	} else
	{
		forwardLeftTalon->Set(Limit(left)*LowSpeedRate);
		forwardRightTalon->Set(Limit(right)*LowSpeedRate);
	}
}

void ForwardDrive::LinearDrive(float inches)
{
	forwardLeftTalon->Set(inches*LeftPulsesPerInch);
	forwardRightTalon->Set(inches*RightPulsesPerInch);
}

void ForwardDrive::Pivot(float degrees)
{
	if (degrees >= 0.0)
	{
		forwardLeftTalon->Set(degrees*PulsesPerDeg);
		forwardRightTalon->Set(-(degrees*PulsesPerDeg));
	} else
	{
		forwardLeftTalon->Set(-(degrees*PulsesPerDeg));
		forwardRightTalon->Set(degrees*PulsesPerDeg);
	}
}

void ForwardDrive::Stop()
{
	forwardRightTalon->Disable();
	forwardLeftTalon->Disable();
}

void ForwardDrive::Set_PositionMode()
{
	forwardLeftTalon->SetControlMode(CANSpeedController::kPosition);
	forwardRightTalon->SetControlMode(CANSpeedController::kPosition);
	Zero_Encoders();
}

void ForwardDrive::Set_VoltageMode()
{
	forwardLeftTalon->SetControlMode(CANSpeedController::kPercentVbus);
	forwardRightTalon->SetControlMode(CANSpeedController::kPercentVbus);
}

void ForwardDrive::Zero_Encoders()
{
	forwardRightTalon->SetPosition(0);
	forwardLeftTalon->SetPosition(0);
}

int ForwardDrive::Get_LeftEncoder()
{
	return forwardLeftTalon->GetEncPosition();
}

int ForwardDrive::Get_RightEncoder()
{
	return forwardRightTalon->GetEncPosition();
}

/**
 * Limit motor values to the -1.0 to +1.0 range.
 */
float ForwardDrive::Limit(float num)
{
	if (num > 1.0)
	{
		return 1.0;
	}
	if (num < -1.0)
	{
		return -1.0;
	}
	return num;
}
